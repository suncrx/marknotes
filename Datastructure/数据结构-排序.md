## 一、简单排序算法

### （一）冒泡排序

- **原理**
    - 冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
    - 比如对于一个数组 [5, 3, 8, 4, 2]，在第一轮遍历时，先比较 5 和 3，因为 5 > 3，所以交换它们的位置，数组变为 [3, 5, 8, 4, 2]；接着比较 5 和 8，顺序正确，不交换；然后比较 8 和 4，交换它们的位置，数组变为 [3, 5, 4, 8, 2]；最后比较 8 和 2，交换它们的位置，数组变为 [3, 5, 4, 2, 8]。经过第一轮遍历，最大的数 8“冒泡”到了数组的最后。接下来继续进行第二轮遍历，直到整个数组有序。
- **时间复杂度**
    - 最坏情况下（数组完全逆序），时间复杂度为 O(n^2)，其中 n 是数组的长度。最好情况下（数组已经有序），时间复杂度为 O(n)，可以通过设置一个标志位来判断是否发生了交换，如果没有发生交换，说明数组已经有序，可以提前结束排序。
- **稳定性**
    - 冒泡排序是一种稳定的排序算法。因为当两个相等的元素进行比较时，它们不会被交换，所以相等元素的相对顺序不会改变。

### （二）选择排序

- **原理**
    - 选择排序的基本思想是在每一轮选择中，从未排序的部分找到最小（或最大）的元素，将其放到已排序部分的末尾。
    - 例如对于数组 [64, 25, 12, 22, 11]，在第一轮选择中，从整个数组中找到最小的元素 11，将其与第一个元素 64 交换位置，数组变为 [11, 25, 12, 22, 64]。在第二轮选择中，从剩下的 [25, 12, 22, 64] 中找到最小的元素 12，将其与第二个元素 25 交换位置，数组变为 [11, 12, 25, 22, 64]。如此反复，直到整个数组有序。
- **时间复杂度**
    - 无论数组的初始状态如何，选择排序的时间复杂度都是 O(n^2)，因为每一轮选择都需要遍历剩下的未排序部分来找到最小（或最大）元素。
- **稳定性**
    - 选择排序是不稳定的排序算法。例如在数组 [5, 8, 5, 2] 中，第一个 5 和第二个 5 是相等的元素，当选择最小元素 2 时，它会和第一个 5 交换位置，这样原来第二个 5 在第一个 5 之前的位置关系就被破坏了。

### （三）插入排序

- **原理**
    - 插入排序的工作方式是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。假设有一个数组 [3, 1, 4, 1, 5, 9, 2]，初始时认为第一个元素 3 是一个有序序列。然后从第二个元素开始，取出 1，将其插入到前面的有序序列 [3] 中，得到 [1, 3]；接着取出 4，插入到 [1, 3] 中，得到 [1, 3, 4]；依次类推，直到整个数组有序。
- **时间复杂度**
    - 最坏情况下（数组完全逆序），时间复杂度为 O(n^2)。最好情况下（数组已经有序），时间复杂度为 O(n)，因为每次插入都不需要移动前面的元素。
- **稳定性**
    - 插入排序是一种稳定的排序算法。在插入的过程中，相等元素的相对顺序不会改变。

## 二、高效排序算法

### （一）希尔排序

- **原理**
    - 希尔排序是插入排序的一种改进版本。它通过将记录按不同的步长分组，对每组使用直接插入排序算法排序；随着步长逐渐缩小，整个序列向有序状态演进，最后步长为 1 时，整个序列进行一次直接插入排序后即变成有序序列。
    - 例如，对于数组 [9, 8, 3, 7, 2, 1, 4, 5]，假设初始步长为 4，那么数组可以分为 [9, 3] 和 [8, 7] 和 [2, 4] 和 [1, 5] 这几组，对每组进行插入排序后，数组变为 [3, 7, 2, 1, 9, 8, 4, 5]。然后缩小步长，继续分组排序，直到步长为 1，进行最后一次插入排序，得到有序数组。
- **时间复杂度**
    - 希尔排序的时间复杂度取决于步长序列。一般来说，时间复杂度在 O(nlogn) 到 O(n^2) 之间。合适的步长序列可以提高排序效率。
- **稳定性**
    - 希尔排序是不稳定的排序算法。因为在分组和插入过程中，相等元素的相对顺序可能会改变。

### （二）归并排序

- **原理**
    - 归并排序是建立在归并操作上的一种有效的排序算法。它采用分治法的思想，将两个（或两个以上）有序表合并成一个新的有序表。例如，对于数组 [38, 27, 43, 3, 9, 82, 10]，先将数组分成两部分 [38, 27, 43, 3] 和 [9, 82, 10]，然后分别对这两部分进行归并排序。对于 [38, 27, 43, 3]，再分成 [38, 27] 和 [43, 3]，继续分解，直到每个子数组只有一个元素。然后开始合并，先合并 [38, 27] 得到 [27, 38]，合并 [43, 3] 得到 [3, 43]，再将 [27, 38] 和 [3, 43] 合并得到 [3, 27, 38, 43]。对另一部分 [9, 82, 10] 也进行类似操作，最后将两部分合并得到有序数组。
- **时间复杂度**
    - 归并排序的时间复杂度为 O(nlogn)，其中 n 是数组的长度。这是因为每次分解和合并操作的时间复杂度都是线性的，而分解的深度是 logn。
- **稳定性**
    - 归并排序是一种稳定的排序算法。在合并过程中，相等元素的相对顺序不会改变。

### （三）快速排序

- **原理**
    - 快速排序是一种分而治之的排序算法。它的基本思想是选择一个基准值（pivot），通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字都比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
    - 例如对于数组 [6, 1, 2, 7, 9, 3, 4, 5, 10, 8]，选择第一个元素 6 作为基准值。通过一趟排序，将小于 6 的元素移到左边，大于 6 的元素移到右边，得到 [5, 1, 2, 4, 3, 6, 9, 7, 10, 8]。然后对 [5, 1, 2, 4, 3] 和 [9, 7, 10, 8] 这两部分分别进行快速排序，直到整个数组有序。
- **时间复杂度**
    - 平均情况下，快速排序的时间复杂度为 O(nlogn)。但是最坏情况下（数组已经有序或者完全逆序），时间复杂度会退化到 O(n^2)。不过，通过选择合适的基准值（如随机选择基准值）可以避免这种情况。
- **稳定性**
    - 快速排序是不稳定的排序算法。在划分过程中，相等元素的相对顺序可能会改变。

### （四）堆排序

- **原理**
    - 堆排序利用了堆这种数据结构。首先将待排序的数据构建成一个最大堆（假设是升序排序）。然后将堆顶元素（最大值）与最后一个元素交换，这样最大值就到了数组的最后。接着，重新调整剩余的堆结构，使其仍然满足最大堆的性质。
    - 在堆排序中，重新调整堆的过程称为“堆调整”或“下沉”操作。以最大堆为例，假设当前堆顶元素被移除（与最后一个元素交换后），需要将新的堆顶元素调整到合适的位置，以维持最大堆的性质。
    - 例如，对于数组 [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]，首先将其构建成一个最大堆。堆顶元素是 16。将 16 与最后一个元素 1 交换，数组变为 [1, 14, 10, 8, 7, 9, 3, 2, 4, 16]。此时，堆顶元素是 1，需要将其调整到合适的位置。
    - 从堆顶开始，比较 1 和它的子节点 14 和 10。因为 14 > 10 > 1，所以将 14 与 1 交换，数组变为 [14, 1, 10, 8, 7, 9, 3, 2, 4, 16]。然后继续比较 1 和它的新子节点 8 和 7，因为 8 > 7 > 1，所以将 8 与 1 交换，数组变为 [14, 8, 10, 1, 7, 9, 3, 2, 4, 16]。此时，1 已经没有子节点，调整完成。
    - 重复上述过程，每次都将新的堆顶元素调整到合适的位置，直到整个数组有序。堆排序的时间复杂度为 O(nlogn)，其中 n 是数组的长度。这是因为构建堆的过程需要 O(n) 的时间，而每次调整堆的操作需要 O(logn) 的时间，总共需要进行 n 次调整。
- **稳定性**
    - 堆排序是不稳定的排序算法。在调整堆的过程中，相等元素的相对顺序可能会改变。例如，在一个包含多个相同值的数组中，调整堆可能会导致这些相同值的相对位置发生改变。

## 三、其他排序算法

### （1）计数排序

- **原理**
    - 计数排序是一种非比较排序算法，适用于一定范围内的整数排序。它通过统计每个整数出现的次数来实现排序。
    - 例如，对于数组 [4, 2, 2, 8, 3, 3, 1]，首先确定数组中元素的最大值（这里是 8）和最小值（这里是 1）。然后创建一个大小为最大值 - 最小值 + 1 的计数数组，初始化为 0。对于原数组中的每个元素，将其对应的计数数组位置的值加 1。在这个例子中，计数数组为 [0, 1, 2, 2, 1, 0, 0, 0, 1]（下标从 0 开始，对应原数组中的值 1 到 8）。最后，根据计数数组的值，将元素按顺序放入结果数组中，得到排序后的数组 [1, 2, 2, 3, 3, 4, 8]。
- **时间复杂度**
    - 计数排序的时间复杂度为 O(n + k)，其中 n 是数组的长度，k 是数组中元素的范围。当 k 不大时，计数排序非常高效。
- **稳定性**
    - 计数排序是一种稳定的排序算法。在统计和输出过程中，相等元素的相对顺序不会改变。

### （2）基数排序

- **原理**
    - 基数排序也是一种非比较排序算法，它按照从最低位到最高位（LSD）或从最高位到最低位（MSD）的顺序，对每个数位上的数字进行排序。
    - 例如，对于数组 [170, 45, 75, 90, 802, 24, 2, 66]，按照 LSD 的方式，首先对个位数进行排序，使用计数排序或其他稳定排序算法，得到 [170, 90, 802, 2, 24, 45, 75, 66]；然后对十位数进行排序，得到 [802, 2, 24, 45, 66, 170, 75, 90]；最后对百位数进行排序，得到最终的有序数组 [2, 24, 45, 66, 75, 90, 170, 802]。
- **时间复杂度**
    - 基数排序的时间复杂度为 O(d(n + k))，其中 d 是数字的位数，n 是数组的长度，k 是每个数位上的数字范围（通常是 10，对于十进制数）。当数字的位数较少时，基数排序非常高效。
- **稳定性**
    - 基数排序是一种稳定的排序算法。在每个数位上的排序过程中，相等元素的相对顺序不会改变。

### （3）桶排序

- **原理**
    - 桶排序是一种基于分桶思想的排序算法。它将数组中的元素划分到不同的桶中，然后对每个桶内的元素进行排序，最后将所有桶中的元素依次取出，得到有序数组。
    - 例如，对于数组 [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]，假设将这些元素划分到 10 个桶中，每个桶的范围是 [0, 0.1)、[0.1, 0.2)、……、[0.9, 1.0)。将每个元素放入对应的桶中，然后对每个桶内的元素进行排序（可以使用插入排序等简单排序算法）。最后，依次取出每个桶中的元素，得到有序数组 [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]。
- **时间复杂度**
    - 桶排序的时间复杂度为 O(n + k)，其中 n 是数组的长度，k 是桶的数量。当桶的数量适当时，桶排序非常高效。
- **稳定性**
    - 桶排序是一种稳定的排序算法。在对每个桶内的元素进行排序时，相等元素的相对顺序不会改变。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY1MzM5MTI2LDE2NzE5OTg2MDJdfQ==
-->