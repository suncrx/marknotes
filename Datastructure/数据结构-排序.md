## 一、简单排序算法

### （一）冒泡排序

- **原理**
    - 冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
    - 比如对于一个数组 [5, 3, 8, 4, 2]，在第一轮遍历时，先比较 5 和 3，因为 5 > 3，所以交换它们的位置，数组变为 [3, 5, 8, 4, 2]；接着比较 5 和 8，顺序正确，不交换；然后比较 8 和 4，交换它们的位置，数组变为 [3, 5, 4, 8, 2]；最后比较 8 和 2，交换它们的位置，数组变为 [3, 5, 4, 2, 8]。经过第一轮遍历，最大的数 8“冒泡”到了数组的最后。接下来继续进行第二轮遍历，直到整个数组有序。
- **时间复杂度**
    - 最坏情况下（数组完全逆序），时间复杂度为 O(n^2)，其中 n 是数组的长度。最好情况下（数组已经有序），时间复杂度为 O(n)，可以通过设置一个标志位来判断是否发生了交换，如果没有发生交换，说明数组已经有序，可以提前结束排序。
- **稳定性**
    - 冒泡排序是一种稳定的排序算法。因为当两个相等的元素进行比较时，它们不会被交换，所以相等元素的相对顺序不会改变。

### （二）选择排序

- **原理**
    - 选择排序的基本思想是在每一轮选择中，从未排序的部分找到最小（或最大）的元素，将其放到已排序部分的末尾。
    - 例如对于数组 [64, 25, 12, 22, 11]，在第一轮选择中，从整个数组中找到最小的元素 11，将其与第一个元素 64 交换位置，数组变为 [11, 25, 12, 22, 64]。在第二轮选择中，从剩下的 [25, 12, 22, 64] 中找到最小的元素 12，将其与第二个元素 25 交换位置，数组变为 [11, 12, 25, 22, 64]。如此反复，直到整个数组有序。
- **时间复杂度**
    - 无论数组的初始状态如何，选择排序的时间复杂度都是 O(n^2)，因为每一轮选择都需要遍历剩下的未排序部分来找到最小（或最大）元素。
- **稳定性**
    - 选择排序是不稳定的排序算法。例如在数组 [5, 8, 5, 2] 中，第一个 5 和第二个 5 是相等的元素，当选择最小元素 2 时，它会和第一个 5 交换位置，这样原来第二个 5 在第一个 5 之前的位置关系就被破坏了。

### （三）插入排序

- **原理**
    - 插入排序的工作方式是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。假设有一个数组 [3, 1, 4, 1, 5, 9, 2]，初始时认为第一个元素 3 是一个有序序列。然后从第二个元素开始，取出 1，将其插入到前面的有序序列 [3] 中，得到 [1, 3]；接着取出 4，插入到 [1, 3] 中，得到 [1, 3, 4]；依次类推，直到整个数组有序。
- **时间复杂度**
    - 最坏情况下（数组完全逆序），时间复杂度为 O(n^2)。最好情况下（数组已经有序），时间复杂度为 O(n)，因为每次插入都不需要移动前面的元素。
- **稳定性**
    - 插入排序是一种稳定的排序算法。在插入的过程中，相等元素的相对顺序不会改变。

## 二、高效排序算法

### （一）希尔排序

- **原理**
    - 希尔排序是插入排序的一种改进版本。它通过将记录按不同的步长分组，对每组使用直接插入排序算法排序；随着步长逐渐缩小，整个序列向有序状态演进，最后步长为 1 时，整个序列进行一次直接插入排序后即变成有序序列。
    - 例如，对于数组 [9, 8, 3, 7, 2, 1, 4, 5]，假设初始步长为 4，那么数组可以分为 [9, 3] 和 [8, 7] 和 [2, 4] 和 [1, 5] 这几组，对每组进行插入排序后，数组变为 [3, 7, 2, 1, 9, 8, 4, 5]。然后缩小步长，继续分组排序，直到步长为 1，进行最后一次插入排序，得到有序数组。
- **时间复杂度**
    - 希尔排序的时间复杂度取决于步长序列。一般来说，时间复杂度在 O(nlogn) 到 O(n^2) 之间。合适的步长序列可以提高排序效率。
- **稳定性**
    - 希尔排序是不稳定的排序算法。因为在分组和插入过程中，相等元素的相对顺序可能会改变。

### （二）归并排序

- **原理**
    - 归并排序是建立在归并操作上的一种有效的排序算法。它采用分治法的思想，将两个（或两个以上）有序表合并成一个新的有序表。例如，对于数组 [38, 27, 43, 3, 9, 82, 10]，先将数组分成两部分 [38, 27, 43, 3] 和 [9, 82, 10]，然后分别对这两部分进行归并排序。对于 [38, 27, 43, 3]，再分成 [38, 27] 和 [43, 3]，继续分解，直到每个子数组只有一个元素。然后开始合并，先合并 [38, 27] 得到 [27, 38]，合并 [43, 3] 得到 [3, 43]，再将 [27, 38] 和 [3, 43] 合并得到 [3, 27, 38, 43]。对另一部分 [9, 82, 10] 也进行类似操作，最后将两部分合并得到有序数组。
- **时间复杂度**
    - 归并排序的时间复杂度为 O(nlogn)，其中 n 是数组的长度。这是因为每次分解和合并操作的时间复杂度都是线性的，而分解的深度是 logn。
- **稳定性**
    - 归并排序是一种稳定的排序算法。在合并过程中，相等元素的相对顺序不会改变。

### （三）快速排序

- **原理**
    - 快速排序是一种分而治之的排序算法。它的基本思想是选择一个基准值（pivot），通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字都比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
    - 例如对于数组 [6, 1, 2, 7, 9, 3, 4, 5, 10, 8]，选择第一个元素 6 作为基准值。通过一趟排序，将小于 6 的元素移到左边，大于 6 的元素移到右边，得到 [5, 1, 2, 4, 3, 6, 9, 7, 10, 8]。然后对 [5, 1, 2, 4, 3] 和 [9, 7, 10, 8] 这两部分分别进行快速排序，直到整个数组有序。
- **时间复杂度**
    - 平均情况下，快速排序的时间复杂度为 O(nlogn)。但是最坏情况下（数组已经有序或者完全逆序），时间复杂度会退化到 O(n^2)。不过，通过选择合适的基准值（如随机选择基准值）可以避免这种情况。
- **稳定性**
    - 快速排序是不稳定的排序算法。在划分过程中，相等元素的相对顺序可能会改变。

### （四）堆排序

- **原理**
    - 堆排序利用了堆这种数据结构。首先将待排序的数据构建成一个最大堆（假设是升序排序）。然后将堆顶元素（最大值）与最后一个元素交换，这样最大值就到了数组的最后。接着，重新调整剩余的堆结构，使其仍然满足最大堆的性质
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTY3MTk5ODYwMl19
-->